

#include <way.h>
#include <show.h>
#include "io.h"
#include <myfile.h>
#include "MyMatrix.h"

int pc_order = 0;

struct _globals
{
	int order_flag;
	int start_flag;
	pthread_mutex_t db;
	pthread_cond_t db_update;
	unsigned char *buf;
	int size;

	int outcnt;
} global;

//--------------定义环形链表操作的锁------------------
pthread_mutex_t db_link;
//pthread_cond_t  db_update;

//-----------------------------------
struct timeval tv_glo;
struct timeval tv_glo_pre;

PNODE phead = NULL;
PNODE phead_rec = NULL;

char all_ip[7][14] = {"192.168.0.201",
					  "192.168.0.202",
					  "192.168.0.203",
					  "192.168.0.204",
					  "192.168.0.205",
					  "192.168.0.206",
					  "192.168.0.207"};

pthread_mutex_t g_tMutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t g_tConVar = PTHREAD_COND_INITIALIZER;

pthread_mutex_t g_tMutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t g_tConVar1 = PTHREAD_COND_INITIALIZER;

T_VideoBuf tConvertBuf_now;
T_VideoBuf tConvertBuf_mid;
void *socket_send(void *povid);
void *socket_receive(void *povid);

//----------------------
void *VideoTreadFunction(void *povid)
{
	chose_xy();
	int iError;
	T_VideoDevice tVideoDevice; //
	PT_VideoConvert ptVideoConvert;
	int iPixelFormatOfVideo;
	int iPixelFormatOfDisp;

	PT_VideoBuf ptVideoBufCur; //
	PT_VideoBuf ptVideoBufCur_old;
	T_VideoBuf tVideoBuf; //
	T_VideoBuf tConvertBuf;
	T_VideoBuf tZoomBuf;
	T_VideoBuf tFrameBuf; //

	int iLcdWidth;
	int iLcdHeigt;
	int iLcdBpp;

	struct timeval tv;

	//-------------------------------------
	//---------------------显示屏初始化------------------------------------
	DisplayInit();
	SelectAndInitDefaultDispDev("fb");
	GetDispResolution(&iLcdWidth, &iLcdHeigt, &iLcdBpp);

	GetVideoBufForDisplay(&tFrameBuf);
	iPixelFormatOfDisp = tFrameBuf.iPixelFormat;
	//----------------------摄像头初始化--------------------------------
	VideoInit();
	iError = VideoDeviceInit("/dev/video4", &tVideoDevice);
	iPixelFormatOfVideo = tVideoDevice.ptOPr->GetFormat(&tVideoDevice);

	VideoConvertInit();
	ptVideoConvert = GetVideoConvertForFormats(iPixelFormatOfVideo, iPixelFormatOfDisp);
	if (NULL == ptVideoConvert)
	{
		DBG_PRINTF("can not support this format convert\n");
	}

	iError = tVideoDevice.ptOPr->StartDevice(&tVideoDevice);
	if (iError)
	{
	}

	memset(&tVideoBuf, 0, sizeof(tVideoBuf));
	memset(&tConvertBuf, 0, sizeof(tConvertBuf));
	tConvertBuf.iPixelFormat = iPixelFormatOfDisp;
	tConvertBuf.tPixelDatas.iBpp = iLcdBpp;
	memset(&tZoomBuf, 0, sizeof(tZoomBuf));

	//------------------------主循环部分-----------------------
	while (1)
	{ // gettimeofday(&tv,NULL);
		// DBG_PRINTF("time1 is %f \n", tv.tv_sec+tv.tv_usec/1000000.);
		//-----------从缓冲区中得到图像---------------------
		iError = tVideoDevice.ptOPr->GetFrame(&tVideoDevice, &tVideoBuf);

		//ptVideoBufCur = &tVideoBuf;

		//--------------采集图像格式与显示格式不同----------------

		iError = ptVideoConvert->Convert(&tVideoBuf, &tConvertBuf);
		ptVideoBufCur = &tConvertBuf;

		tVideoDevice.ptOPr->PutFrame(&tVideoDevice, &tVideoBuf);
		//------------------图像处理部分-------------------------------
		// / gettimeofday(&tv,NULL);
		//		DBG_PRINTF("time2 is %f \n", tv.tv_sec+tv.tv_usec/1000000.);

		scan(tConvertBuf.tPixelDatas.aucPixelDatas); //消耗51毫秒
													 //find_dir(tConvertBuf.tPixelDatas.aucPixelDatas);
													 //gettimeofday(&tv,NULL);
													 // DBG_PRINTF("time3 is %f \n", tv.tv_sec+tv.tv_usec/1000000.);

		pthread_mutex_lock(&g_tMutex);

		//-----------------------------------------------
		//tFrameBuf_mid=tFrameBuf; //
		// tConvertBuf_mid=tConvertBuf;

		tConvertBuf_mid.tPixelDatas.iWidth = tConvertBuf.tPixelDatas.iWidth;
		tConvertBuf_mid.tPixelDatas.iHeight = tConvertBuf.tPixelDatas.iHeight;
		tConvertBuf_mid.tPixelDatas.iBpp = tConvertBuf.tPixelDatas.iBpp;
		tConvertBuf_mid.tPixelDatas.iLineBytes = tConvertBuf.tPixelDatas.iLineBytes;
		tConvertBuf_mid.tPixelDatas.iTotalBytes = tConvertBuf.tPixelDatas.iTotalBytes;
		if (!tConvertBuf_mid.tPixelDatas.aucPixelDatas)
		{
			tConvertBuf_mid.tPixelDatas.aucPixelDatas = malloc(tConvertBuf.tPixelDatas.iTotalBytes);
		}
		//----------拷贝函数耗时2毫秒-----------
		memcpy(tConvertBuf_mid.tPixelDatas.aucPixelDatas, tConvertBuf.tPixelDatas.aucPixelDatas, 800 * 600 * 4);

		//-----------------------------------------------
		pthread_cond_signal(&g_tConVar);
		/* 释放互斥量 */
		pthread_mutex_unlock(&g_tMutex);
		/*  唤醒主线程 */
	}
}

//=================================================
//===
//===
//==========================================

int main(int argc, char **argv)

{
	Matrix A = Create_Matrix(4, 4);
    Matrix H = Create_Matrix(2, 4);
    Matrix X = Create_Matrix(4, 1);
    Matrix X_= Create_Matrix(4, 1);
    Matrix P = Create_Matrix(4, 4);
    Matrix P_= Create_Matrix(4, 4);
    Matrix K = Create_Matrix(4, 4);
    Matrix K_= Create_Matrix(4, 2);
    Matrix K__=Create_Matrix(2, 2);
    Matrix Z = Create_Matrix(2, 1);
	struct timeval tv1;
	int i = 0;
	int choice_x = 0;
	int choice_y = 0;
	int count = 0;
	int differ = 0;
	int ts = 0;
	int counter = 0;
	int get_x;
	int get_y;
	int get_tht;

	int dlta_d;
	int dlta_a;
	//-----------io---------------
	int usart_fd = 0;
	int can_fd = 0;
	int file_fd = 0;
	unsigned char get_data[8];
	int read_num = 0;
	float sin_count = 0.001;
	

	file_flag = -1; //1不操作文件，1操作文件
	int file_size = 0;
	get_time.start_flag = 0;
	get_time.time_flag = 0;
	P = eye(4);

	

	//----------------------------
	T_InputEvent tInputEvent;
	T_VideoBuf tFrameBuf_main; //
	pthread_t tTreadID1;
	pthread_t tTreadID2;
	pthread_t tTreadID3;

	//signal(SIGCHLD,SIG_IGN);
	signal(SIGPIPE, SIG_IGN);

	pthread_mutex_init(&global.db, NULL); /* 初始化 global.db 成员 */
	pthread_mutex_init(&db_link, NULL);	  //--用于操作链表

	pthread_cond_init(&global.db_update, NULL); /* 初始化 global.db_update(条件变量) 成员 */
	global.order_flag = 0;
	global.start_flag = 0;

	/* 创建子线程 */

	pthread_create(&tTreadID3, NULL, socket_receive, NULL);
	pthread_create(&tTreadID2, NULL, socket_send, NULL);

	//先放在后面，先让出通信所需的资源

	pthread_create(&tTreadID1, NULL, VideoTreadFunction, NULL);

	InputInit();
	AllInputDevicesInit();

	hzk_init();

	usart_fd = usart_init();
	can_fd = can_init();
	file_fd = file_init();
	
	//close(file_fd);
	ask_data[0] = 0x68;
	ask_data[1] = 0x04;
	ask_data[2] = 0x00;
	ask_data[3] = 0x03;
	ask_data[4] = 0x07;

	frame_send.can_id = 0x80cc0000;
	frame_send.data[0] = 0xfb;
	frame_send.data[1] = 0;
	frame_send.data[2] = 0;
	frame_send.data[3] = 0;
	frame_send.data[4] = 0;
	frame_send.data[5] = 0;
	frame_send.data[6] = 00;
	frame_send.data[7] = 00;
	frame_send.can_dlc = 8;
	GetVideoBufForDisplay(&tFrameBuf_main);

	DBG_PRINTF("x %d\n", tFrameBuf_main.tPixelDatas.iWidth);
	DBG_PRINTF("y %d\n", tFrameBuf_main.tPixelDatas.iHeight);

	switch (pc_order)
		{
		case 0:
			dlta_d = 0;
			dlta_a = 0;
			break;
		case 1:
			dlta_d = 50;
			dlta_a = 0;
			break;
		case 2:
			dlta_d = -200;
			dlta_a = 0;
			break;
		case 3:
			dlta_d = 0;
			dlta_a = 300;
			break;
		case 4:
			dlta_d = 0;
			dlta_a = -300;
			break;
		case 5:
			dlta_d = 0;
			dlta_a = 0;
			break;
		default:
			break;
		}

	double cooo2[] = {0,90,0,5};
	double cooo1[] = {1,0,0,0,0,1,0,0};
	
	SetData_Matrix(H, cooo1);
	SetData_Matrix(X, cooo2);

	while (1)
	{

		//---------------触摸屏---------------------

		if (0 == GetInputEvent(&tInputEvent))
		{
			DBG_PRINTF("x is %d\n", tInputEvent.x);
			DBG_PRINTF("y is %d\n", tInputEvent.y);
		}

		//---------------------------------------------
		if (tInputEvent.x > 0 && tInputEvent.y > 0)
		{
			choice_x = tInputEvent.x;
			choice_y = tInputEvent.y;
		}

		//out_set(tInputEvent.x,tInputEvent.y,&tFrameBuf_main.tPixelDatas);

		//------------------------------------------


		//if(pc_order==1)
		
			//dlta_d=abs(60);
			//dlta_a=100*sin(sin_count)/pow((1+cos(sin_count)*cos(sin_count)),1.5);
			//sin_count=sin_count+0.01;

			frame_send.data[1] = (int)dlta_d >> 8;
			frame_send.data[2] = (int)dlta_d;
			frame_send.data[3] = (int)dlta_a >> 8;
			frame_send.data[4] = (int)dlta_a;
			frame_send.data[5] = 0;
			nbytes = write(can_fd, &frame_send, sizeof(frame_send));

			//--------------------------------------------------

			addr_len = sizeof(addr);
			len = 0;

			nbytes = recvfrom(s, &frame_rev, sizeof(struct can_frame), 0, (struct sockaddr *)&addr, &len);

			ifr.ifr_ifindex = addr.can_ifindex;
			ioctl(s, SIOCGIFNAME, &ifr);

			get_x = (short)(frame_rev.data[0] * 256 + frame_rev.data[1]);
			get_y = (short)(frame_rev.data[2] * 256 + frame_rev.data[3]);
			get_tht = (short)(frame_rev.data[4] * 256 + frame_rev.data[5]);
		

		//---------------电子罗盘--------------------

		//----------------风速仪-----------------------

		//---------------无线网卡-----------------
		/*int show_i=0;
for(show_i=0;show_i<robot_temp[0].count;show_i++)
	 {
		// xx=show_x[show_i];
		// yy=show_y[show_i];
		 
		file_write_xy(file_fd,show_x[show_i],show_y[show_i]);

	 
	 }

file_write_xy(file_fd,111111111,111111111);
file_write_xy(file_fd,robot_temp[1].rad,robot_temp[1].angle);
file_write_xy(file_fd,robot_temp[2].rad,robot_temp[2].angle);
file_write_xy(file_fd,robot_temp[3].rad,robot_temp[3].angle);
file_write_xy(file_fd,robot_temp[4].rad,robot_temp[4].angle);
file_write_xy(file_fd,robot_temp[5].rad,robot_temp[5].angle);
file_write_xy(file_fd,robot_temp[6].rad,robot_temp[6].angle);




file_write_xy(file_fd,8888888,8888888);
*/
		//---------------文件存取-------------------
		count = get_time.NowMs - get_time.PreMs;
		ts += count -differ;
		differ = count;

		if(counter == 10){
			if (file_flag == -1)
			{
				file_write(file_fd, ts  , get_x, get_y, get_tht, Ture_Tht);
			}
			double cooo[]  = {1,0,ts/1000,0,0,1,0,ts/1000,0,0,1,0,0,0,0,1};
			SetData_Matrix(A, cooo);
			X_ = Mult_Matrix(A, X);
			P_ = Mult_Matrix(Mult_Matrix(A, P),Trans_Matrix(A));
			K_ = Mult_Matrix(P_, Trans_Matrix(H));
			K__= Mult_Matrix(Mult_Matrix(H, P_),Trans_Matrix(H));
			K = Mult_Matrix(K_,EleTransInv_Matrix(K__));
			X = AddorSub_Matrix(X_,Mult_Matrix(K,AddorSub_Matrix(Z,Mult_Matrix(H,X_),1)),0);
			P = AddorSub_Matrix(P_,Mult_Matrix(Mult_Matrix(K,H),P_),1);
			ts = 0;		
		}
		//file_size=get_file_size("./main.o");

		//printf("file size is %d\n",file_size);

		//-----------------综合显示部分------------------------------------

		pthread_mutex_lock(&g_tMutex);

		/* 休眠 */
		pthread_cond_wait(&g_tConVar, &g_tMutex);
		//------------------------------------------------------------------
		/* 被唤醒后,返回数据 */

		tConvertBuf_now = tConvertBuf_mid;

		pthread_mutex_unlock(&g_tMutex);
		if(counter == 10){
			for (i = 1; i <= 1; i++)
			{
				robot_temp[i].dis_diff = robot_temp[i].rad - dis_50;
				//DBG_PRINTF("robot_temp[i].dis_diff %d\n",robot_temp[i].dis_diff);
				if (robot_temp[i].dis_diff < 75)
					robot_temp[i].distance = a11 * pow(a12 * robot_temp[i].dis_diff, a13) + 50;
				if (robot_temp[i].dis_diff >= 75 && robot_temp[i].dis_diff < 146)
					robot_temp[i].distance = a21 * pow(a22 * robot_temp[i].dis_diff, a23) + 50;
				if (robot_temp[i].dis_diff >= 146 && robot_temp[i].dis_diff < 164)
					robot_temp[i].distance = a31 * pow(a32 * robot_temp[i].dis_diff, a33) + 50;
				if (robot_temp[i].dis_diff >= 164)
					robot_temp[i].distance = a41 * pow(a42 * robot_temp[i].dis_diff, a43) + 50;
				//DBG_PRINTF("robot_temp[i].distance %d\n",robot_temp[i].distance);

				//if(robot_temp[i].rad==0){robot_temp[i].distance=0;}
				file_write_xy(file_fd, robot_temp[i].distance, robot_temp[i].angle);
			}
			counter = 0;
		}
		double cooo3[2] ={(double)robot_temp[i].distance*cos((double)robot_temp[i].angle/10),
		(double)robot_temp[i].distance*sin((double)robot_temp[i].angle/10)};
		SetData_Matrix(Z, cooo3);	

		counter++;
		point_get(tInputEvent.x, tInputEvent.y, &tConvertBuf_now.tPixelDatas, &tFrameBuf_main.tPixelDatas);
		min_cir(tConvertBuf_now.tPixelDatas.aucPixelDatas);
		//---------x--y---图像向整个屏幕整合------------------------------
		PicMerge(0, 0, &tConvertBuf_now.tPixelDatas, &tFrameBuf_main.tPixelDatas);
		//----------------显示文字内容-------------------------------------
		show_some(&tFrameBuf_main.tPixelDatas);

		//---------------向整个屏幕绘画--------------------------------------
		FlushPixelDatasToDev(&tFrameBuf_main.tPixelDatas);
		//------------------------保存处理好的图片

		/*FILE *fp = fopen("frame1.jpg", "wb+");
	   if (fp < 0)
	   {
		  DBG_PRINTF("open frame data file failed\n");
		   return -1;
	   }

	   fwrite(ptVideoDevice->pucVideBuf[tV4l2Buf.index], 1, tV4l2Buf.length, fp);
	   fclose(fp);
*/

		//-----------------------------------------
		tInputEvent.x = 0;
		tInputEvent.y = 0;
		//------------------------互斥量用于收发线程---------
		pthread_mutex_lock(&global.db);
		//---------数据拷贝区域----------------------
		for (i = 1; i <= 9; i++)
		{
			robot_end[i].distance = robot_temp[i].distance;
			robot_end[i].angle = robot_temp[i].angle;
		}
		pthread_cond_broadcast(&global.db_update); // 发出一个数据更新的信号，通知发送通道来取数据
		pthread_mutex_unlock(&global.db);		   // 原子操作结束
	}
}

//gettimeofday(&tv1,NULL);
//DBG_PRINTF("time1 is %f \n", tv1.tv_sec+tv1.tv_usec/1000000.);
// printf("recv:%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n", get_data[0], get_data[1], get_data[2], get_data[3],get_data[4], get_data[5], get_data[6], get_data[7]);
//printf("First_Angle %d\n ",First_Angle);
//printf("Ture_Tht %d \n",Ture_Tht);

void *socket_send(void *povid)
{
	PNODE phead_send = NULL;
	
	int once = 1;
	int temp = 0;
	struct timeval tv_limt;
	int time_limt = 0;
	int len = 0;
	int i = 0, j = 1;
	int ReceLen = 0;
	int get_Num = 0;
	// signal(SIGCHLD,SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	send_server_init();
	char buf_n[90];
	char buf_y[90];
	unsigned char *local_ip;
	char *last_ip;
	int last_data;

	signal(SIGPIPE, SIG_IGN);
	//--------------得到本地ip -----------------
	local_ip = GetLocalIp();
	printf("local ip is %s\n", local_ip);
	//----------------------------------------------------------------

	//------------根据自己的ip 等级设置超时时间--------------
	if (strcmp(local_ip, all_ip[0]) == 0)
		time_limt = 1000;
	if (strcmp(local_ip, all_ip[1]) == 0)
		time_limt = 3000;
	if (strcmp(local_ip, all_ip[2]) == 0)
		time_limt = 7000;
	if (strcmp(local_ip, all_ip[3]) == 0)
		time_limt = 15000;
	if (strcmp(local_ip, all_ip[4]) == 0)
		time_limt = 31000;
	if (strcmp(local_ip, all_ip[5]) == 0)
		time_limt = 63000;

	//--------测试------------
	//printf("this number is %d\n",strcmp(all_ip[1],all_ip[0]));
	//---------------------开机加入通信环中------
	sleep(1); //延时一到二秒是必须的

	for (i = 0; i < 7; i++)
	{
		gettimeofday(&tv_glo_pre, NULL);
		rec_content.connet_flag[i] = connect_to(&rec_content.iSocketClient[i], all_ip[i]);

		gettimeofday(&tv_glo, NULL);
		DBG_PRINTF("add time is %f \n", (tv_glo.tv_sec - tv_glo_pre.tv_sec) + (tv_glo.tv_usec / 1000000. - tv_glo_pre.tv_usec / 1000000.));
		if (rec_content.connet_flag[i] == 1) //连接成功加入环形链表中
		{
			pthread_mutex_lock(&db_link);
			if (NULL == findIp(phead_rec, all_ip[i]))
				phead = addBack(phead, i + 1, all_ip[i], rec_content.iSocketClient[i]);
			printf("send fd is %s %d", all_ip[i], rec_content.iSocketClient[i]);
			pthread_mutex_unlock(&db_link);
		}
	}
	showAll(phead);

	//---------------------------------------------
	/*if(strcmp(local_ip,all_ip[0])==0) 
{
   global.order_flag=1;//第一号先得到令牌
  for(i=1;i<7;i++)
  	{
  rec_content.connet_flag[i]=connect_to(&rec_content.iSocketClient[i],all_ip[i]);
  	}
  
}
*/

	printf("..................................................\n");

	//--------------------------------------------------------------------------
	while (1)
	{

		//pthread_mutex_lock( &global.db );
		pthread_cond_wait(&global.db_update, &global.db);
		for (i = 1; i < 7; i++)
		{
			robot_send[i].distance = robot_end[i].distance;
			robot_send[i].angle = robot_end[i].angle;
		}
		pthread_mutex_unlock(&global.db);
		//--------------------------------------------------------------

		if (once == 1)
		{
			once = 0;
			gettimeofday(&tv_limt, NULL);
			get_time.PreMs = tv_limt.tv_sec * 1000 + tv_limt.tv_usec / 1000;
		}
		gettimeofday(&tv_limt, NULL);
		get_time.NowMs = tv_limt.tv_sec * 1000 + tv_limt.tv_usec / 1000;

		if ((get_time.NowMs > get_time.PreMs + time_limt) && get_Num >= 2)
		{
			global.order_flag = 1;
			printf("this is out_time then have own order!\n");
		}
		//------------------------------------------------------
		pthread_mutex_lock(&db_link);
		get_Num = getNum(phead_rec);
		//11printf("phead_rec number is %d\n",get_Num);
		//11 showAll(phead_rec);

		for (i = 0; i < get_Num; i++)
		{

			if (phead_rec->start_connect_flag == 0)
			{
				phead_rec->start_connect_flag = 1;
				phead_rec->connected_flag = connect_to(&temp, phead_rec->send_ip);
				if (phead_rec->connected_flag == 1)
				{
					phead = addBack(phead, phead_rec->send_ip[12] - 48, phead_rec->send_ip, temp);
					//11  printf("rece send fd is %s %d",phead_rec->send_ip,temp);
				}
			}
			phead_rec = phead_rec->pNext;
		}
		//11 showAll(phead);

		get_Num = getNum(phead);
		//11printf("phead number is %d\n",get_Num);
		phead_send = phead;
		pthread_mutex_unlock(&db_link);
		//---------------------------------------------------------
		// printf("send num is %d\n",get_Num);
		if (global.order_flag == 1 && get_Num >= 2)
		{

			global.order_flag = 0;

			sprintf(buf_n, "%s%s%d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d", "n", local_ip, robot_temp[0].number, "-", "d", robot_send[1].distance, "a", robot_send[1].angle, "-", "d", robot_send[2].distance, "a", robot_send[2].angle, "-", "d", robot_send[3].distance, "a", robot_send[3].angle, "-", "d", robot_send[4].distance, "a", robot_send[4].angle, "-", "d", robot_send[5].distance, "a", robot_send[5].angle, "-", "d", robot_send[6].distance, "a", robot_send[6].angle);
			sprintf(buf_y, "%s%s%d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d", "y", local_ip, robot_temp[0].number, "-", "d", robot_send[1].distance, "a", robot_send[1].angle, "-", "d", robot_send[2].distance, "a", robot_send[2].angle, "-", "d", robot_send[3].distance, "a", robot_send[3].angle, "-", "d", robot_send[4].distance, "a", robot_send[4].angle, "-", "d", robot_send[5].distance, "a", robot_send[5].angle, "-", "d", robot_send[6].distance, "a", robot_send[6].angle);

			//--------------------链表排序---------------

			phead_send = sortLink(phead_send);
			//showAll(phead_send);

			//-------------------发送数据----------------
			phead_send = findIp(phead_send, local_ip);
			phead_send = phead_send->pNext->pNext;

			for (i = 0; i < get_Num; i++)
			{

				gettimeofday(&tv_glo_pre, NULL);

				ReceLen = send(phead_send->iSocketClient, i < get_Num - 1 ? buf_n : buf_y, strlen(buf_n), 0);
				gettimeofday(&tv_glo, NULL);
				DBG_PRINTF("send time is %f \n", (tv_glo.tv_sec - tv_glo_pre.tv_sec) + (tv_glo.tv_usec / 1000000. - tv_glo_pre.tv_usec / 1000000.));

				if (ReceLen <= 0)
				{
					phead_send = deleteFirst(phead_send, phead_send->data);
					//pthread_mutex_lock(&db_link);
					// phead=deleteFirst(phead,phead_send->data);
					//pthread_mutex_unlock(&db_link);
				}

				phead_send = phead_send->pNext;
			}
			//11 printf("phead_send number is %d\n",getNum(phead_send));
			//11 showAll(phead_send);
			pthread_mutex_lock(&db_link);
			phead = phead_send;
			pthread_mutex_unlock(&db_link);

			//--------------------更新初始时间--------
			gettimeofday(&tv_limt, NULL);
			get_time.PreMs = tv_limt.tv_sec * 1000 + tv_limt.tv_usec / 1000;
		}

		/*if(global.start_flag==1)
{
		if(once==1)
			{
			once=0;
			gettimeofday(&tv_limt,NULL);	
			get_time.PreMs=tv_limt.tv_sec*1000+tv_limt.tv_usec/1000;

		    }
	     gettimeofday(&tv_limt,NULL);
	     get_time.NowMs=tv_limt.tv_sec*1000+tv_limt.tv_usec/1000;
//-----------------超时处理---------------------------------
     if(get_time.NowMs>get_time.PreMs+time_limt)	
       {
      global.order_flag=1;
	  printf("this is out_time then have own order!\n");
	   }

//---------------------------------------------------------------
   if(global.order_flag==1)	
    {

    global.order_flag=0;
	    
    sprintf(buf_n,"%s%s%d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d","n",local_ip,robot_temp[0].number, "-","d",robot_send[1].distance,"a",robot_send[1].angle,"-","d",robot_send[2].distance,"a",robot_send[2].angle,"-","d",robot_send[3].distance,"a",robot_send[3].angle,"-","d",robot_send[4].distance,"a",robot_send[4].angle,"-","d",robot_send[5].distance,"a",robot_send[5].angle,"-","d",robot_send[6].distance,"a",robot_send[6].angle);
    sprintf(buf_y,"%s%s%d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d","y",local_ip,robot_temp[0].number, "-","d",robot_send[1].distance,"a",robot_send[1].angle,"-","d",robot_send[2].distance,"a",robot_send[2].angle,"-","d",robot_send[3].distance,"a",robot_send[3].angle,"-","d",robot_send[4].distance,"a",robot_send[4].angle,"-","d",robot_send[5].distance,"a",robot_send[5].angle,"-","d",robot_send[6].distance,"a",robot_send[6].angle);

   //-----------------------------------------------
   phead_send=findIp(phead,local_ip);
 
   phead_send=phead_send->pNext->pNext;
   //last_ip=phead_send->send_ip;
  //last_data=phead_send->data;
  // phead_send=phead_send->pNext;
   get_Num=getNum(phead_send);
 
//--------------------------------先连接主机---------------------------
   for(i=0;i<get_Num;i++) 
   	 {
   
     if( phead_send->start_connect_flag==0)
     	{
     	 phead_send->start_connect_flag=1;
		 if(strcmp(local_ip,phead_send->send_ip)!=0) 
		 	{
             phead_send->connected_flag=connect_to(&(phead_send->iSocketClient),phead_send->send_ip);
            // rec_content.connect_fd[i]=phead_send->data;
		 	}
		 phead_send=phead_send->pNext;
     	}
     }
  
//---------------然后发送数据-------------------------------------
 phead_send=findIp(phead,local_ip);
  phead_send=phead_send->pNext->pNext;

      for(i=0;i<get_Num;i++)
        {
         
           if(phead_send->connected_flag==1)
             {
              ReceLen=send(phead_send->iSocketClient, i<get_Num-1 ? buf_n :buf_y, strlen(buf_n), 0);
			      if(ReceLen<=0)
				   { 
              	   phead_send->connected_flag=0;
			        phead_send=deleteFirst(phead_send,phead_send->data);
					
					}
		     }
		   phead_send=phead_send->pNext;
        }
	  showAll(phead_send);

	  gettimeofday(&tv_limt,NULL);	  
	  get_time.PreMs=tv_limt.tv_sec*1000+tv_limt.tv_usec/1000;
		
	
	phead=phead_send;

  
  
  
   //-------------------------------------------------
   }
}
*/
	}
}
//===========================================
//----------------------接受线程-----------------------
//============================================
void *client_thread(void *arg)
{
	int i = 0, j = 0;
	int iRecvLen;
	int SendLen = 0;
	char buf[80];
	unsigned char ucRecvBuf[1000];
	int iClientNum = -1;
	char *local_ip = NULL;
	pt_net_rec p_net_rec = (t_net_rec *)malloc(sizeof(t_net_rec) + 20 * sizeof(char));
	memcpy(p_net_rec, arg, sizeof(t_net_rec) + 20 * sizeof(char));
	printf("now connect ip is %s\n", p_net_rec->ip);
	local_ip = GetLocalIp();

	//----------------------对于符合访问条件的加入链表中-------

	pthread_mutex_lock(&db_link);

	if (strcmp(local_ip, p_net_rec->ip) != 0)
		if (NULL == findIp(phead, p_net_rec->ip) && p_net_rec->ip[10] != 49)
		{

			phead_rec = addBack_rec(phead_rec, p_net_rec->ip[12] - 48, p_net_rec->ip);
		}

	pthread_mutex_unlock(&db_link);
	//printf("there has %d node\n",getNum(phead));
	showAll(phead_rec);

	//-------------------------------------------------------------
	while (1)
	{
		//printf("this is %d\n",p_net_rec->iSocketClient);
		// printf("count is %d\n",iClientNum++);
		//  printf("Get connect from client %d : %s\n",  iClientNum, p_net_rec->ip);

		iRecvLen = recv(p_net_rec->iSocketClient, ucRecvBuf, 999, 0);
		//	printf("Get Msg From Client %d\n", iRecvLen);
		//printf("receive is %d %d %d \n",ucRecvBuf[0],ucRecvBuf[1],ucRecvBuf[2]);
		//send(p_net_rec->iSocketClient, "123\n", strlen("123\n"), 0);

		if (iRecvLen <= 0)
		{
			close(p_net_rec->iSocketClient);
			return -1;
		}
		else
		{
			ucRecvBuf[14] = '\0';
			printf("Get Msg From Client %d: %s\n", iRecvLen, ucRecvBuf);
			//-------------------------------------------------------------
			if (ucRecvBuf[0] == 'o')
			{
				while (1)
				{
					//pthread_mutex_lock( &global.db );
					pthread_cond_wait(&global.db_update, &global.db);

					for (i = 1; i < 7; i++)
					{
						robot_rece[i].distance = robot_end[i].distance;
						robot_rece[i].angle = robot_end[i].angle;
					}
					pthread_mutex_unlock(&global.db);

					sprintf(buf, "%d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s%s%4d%s%4d%s", robot_temp[0].number,
							"-", "d", robot_rece[1].distance, "a", robot_rece[1].angle,
							"-", "d", robot_rece[2].distance, "a", robot_rece[2].angle,
							"-", "d", robot_rece[3].distance, "a", robot_rece[3].angle,
							"-", "d", robot_rece[4].distance, "a", robot_rece[4].angle,
							"-", "d", robot_rece[5].distance, "a", robot_rece[5].angle,
							"-", "d", robot_rece[6].distance, "a", robot_rece[6].angle, "\n");
					SendLen = send(p_net_rec->iSocketClient, buf, strlen(buf), 0);
					printf("send flag is %d \n", SendLen);
					if (SendLen <= 0)
					{
						close(p_net_rec->iSocketClient);
						pthread_exit((void *)8);
						break;
					}
					printf("send to host \n");
				}
			}
			//------------------------------------------------------------------
			if (ucRecvBuf[0] == 'y' || ucRecvBuf[0] == 'n')
			{
				if (ucRecvBuf[0] == 'y')
				{
					printf("------------------------I get a order-------form %c------\n", ucRecvBuf[13]);
					global.order_flag = 1;
				}
				//--------------------------------------
				//pthread_mutex_lock(&db_link);

				//findIp(phead_rec,p_net_rec->ip)
				//{
				//phead_rec=addBack_rec(phead_rec,p_net_rec->ip[12]-48,p_net_rec->ip);
				// }
				//pthread_mutex_unlock(&db_link);
				//----------------------------------------------------
			}
			//-------------------------加入链表------------------------------------------
			/*if(ucRecvBuf[0]=='s')
		{
printf("get string len is %d\n",strlen(ucRecvBuf));
if(strlen(ucRecvBuf)>=6&&phead==NULL)
{
	local_ip=GetLocalIp();
    j=1;
  for(i=0;i<strlen(ucRecvBuf)/2-1;i++)
     {
	      phead=addBack(phead,j++,all_ip[ucRecvBuf[i*2+3]-48-1]);
		  phead->connected_flag=0;
		  phead->iSocketClient=0;
		  phead->start_connect_flag=0;	
     }
for(i=0;i<strlen(ucRecvBuf)/2-1;i++)
	  {
		   phead->connected_flag=0;
		   phead->iSocketClient=0;
		   phead->start_connect_flag=0;	
		  phead=phead->pNext;
	  }


  
  showAll(phead);
  printf("all link number is %d\n",getNum(phead));
}
global.start_flag=1;		
        }
*/
			if (ucRecvBuf[0] == 'r')
			{
				unsigned char buff[100];
				sprintf(buff, "%s%s", local_ip, " connect!\n");

				send(p_net_rec->iSocketClient, buff, strlen(buff), 0);
			}

			if (ucRecvBuf[0] == 'p')
			{
				pc_order = ucRecvBuf[2] - 48;
			}
			if (ucRecvBuf[0] == 'u')
			{
				int fd_file;
				struct stat fd_stat;
				unsigned char *filemem;

				fd_file = open("main.o", O_RDONLY);

				if (fd_file < 0)
				{
					printf("can't open HZK16\n");
					return -1;
				}
				if (fstat(fd_file, &fd_stat))
				{
					printf("can't get fstat\n");
					return -1;
				}
				filemem = (unsigned char *)mmap(NULL, fd_stat.st_size, PROT_READ, MAP_SHARED, fd_file, 0);
				if (filemem == (unsigned char *)-1)
				{
					printf("can't mmap for hzk16\n");
					return -1;
				}
				printf("file size is %d\n", fd_stat.st_size);
				printf("start send file\n");
				//filemem[fd_stat.st_size-1]='\0';
				send(p_net_rec->iSocketClient, filemem, fd_stat.st_size, 0);
				printf("end send file\n");
			}

			//--------------------------------------------------------------------
		}
	}
}

//---------------------------------------------
void *socket_receive(void *povid)
{
	int on = 1;
	void *tret;
	pthread_t client;
	int iSocketServer;
	int iSocketClient;
	struct sockaddr_in tSocketServerAddr;
	struct sockaddr_in tSocketClientAddr;
	int iRet;
	int iAddrLen;

	int iClientNum = -1;
	// pt_net_rec p_net_rec=(t_net_rec *)malloc(sizeof(t_net_rec)+20*sizeof(char));
	// signal(SIGCHLD,SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	iSocketServer = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == iSocketServer)
	{
		printf("socket error!\n");
		return -1;
	}
	//-------------------------------------------------
	if (setsockopt(iSocketServer, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
	{
		perror("setsockopt(SO_REUSEADDR) failed");
		exit(EXIT_FAILURE);
	}

	//-------------------------------------------------
	tSocketServerAddr.sin_family = AF_INET;
	tSocketServerAddr.sin_port = htons(SERVER_PORT); /* host to net, short */
	tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;
	memset(tSocketServerAddr.sin_zero, 0, 8);
	iRet = bind(iSocketServer, (const struct sockaddr *)&tSocketServerAddr, sizeof(struct sockaddr));
	if (-1 == iRet)
	{
		printf("bind error!\n");
		return -1;
	}

	iRet = listen(iSocketServer, BACKLOG);
	printf("listen ok\n");
	if (-1 == iRet)
	{
		printf("listen error!\n");
		return -1;
	}

	while (1)
	{
		pt_net_rec p_net_rec = (t_net_rec *)malloc(sizeof(t_net_rec) + 20 * sizeof(char));

		iAddrLen = sizeof(struct sockaddr);
		printf("start accept \n");
		iSocketClient = accept(iSocketServer, (struct sockaddr *)&tSocketClientAddr, &iAddrLen);
		printf("accept ok \n");
		if (-1 != iSocketClient)
		{
			p_net_rec->ip = inet_ntoa(tSocketClientAddr.sin_addr);
			p_net_rec->iSocketClient = iSocketClient;
			//	iClientNum++;

			printf("befor Get connect from client %d : %s\n", iClientNum, inet_ntoa(tSocketClientAddr.sin_addr));

			pthread_create(&client, NULL, &client_thread, p_net_rec);

			//	pthread_detach(client);	// 等待线程结束,回收资源
			//   pthread_join(client,&tret);
			//  printf("thread exit code %ld \n",(long)tret);
		}
	}

	close(iSocketServer);
	return 0;
}
